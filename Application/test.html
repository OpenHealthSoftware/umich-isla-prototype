<map name="map" id="gridMap">
</map>
<style>
 area {cursor: pointer;}
</style>
<!--
<img usemap="#map" id="grid" src="fullgrid1.png" width="490" height="419">
<canvas id="myCanvas" width="490" height="419" style="border:1px solid #d3d3d3;"></canvas>
<canvas id="results" width="490" height="419" style="border:1px solid #d3d3d3;"></canvas>
-->
<!--
<img usemap="#map" id="grid" src="fullgrid4.png" width="483" height="483">
<canvas id="myCanvas" width="483" height="483" style="border:1px solid #d3d3d3;"></canvas>
<canvas id="results" width="483" height="483" style="border:1px solid #d3d3d3;"></canvas>
-->

<img  usemap="#map" id="grid" src="fullgrid2.png" width="455" height="305">
<canvas id="myCanvas" width="455" height="305" style="border:1px solid #d3d3d3;"></canvas>
<canvas id="results" width="455" height="305" style="border:1px solid #d3d3d3;"></canvas>


<p id="asdf">a</p>
<button onclick="run(2,3)">Run</button>

<script>

numCells = 0;



class Pixel 
{
	constructor(inX, inY, inImgData)
	{
		this.x = inX;
		this.y = inY;
		this.imgData = inImgData;
		
	}

	// Thanks to TIm Down on stackoverflow
	componentToHex(c) 
	{
		var hex = c.toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}
	rgbToHex(r, g, b) 
	{
		return "#" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
	}



	getHex()
	{
		var idx = (this.y * this.imgData.width + this.x) * 4;
		return this.rgbToHex(this.imgData.data[idx], this.imgData.data[idx+1], this.imgData.data[idx+2]);
	}

	// Requires: Degree values that are multiples of 90
	// Effects: returns a pixel location right relative to its current orientation in degrees
	moveRight(deg)
	{
		this.deg = deg;
		
		if (deg % 360 == 0) // absolute up right orientation 
			this.x += 1;
		else if (deg % 450 == 0) // rotated 90deg cw
			this.y += 1;
		else if (deg % 540 == 0) // rotated 180 deg cw
			this.x -= 1;
		else // rotated 270deg cw
			this.y -= 1; 
	}
	moveUp(deg)
	{
		this.deg = deg;
		
		if (deg % 360 == 0) // absolute up right orientation 
			this.y -= 1;
		else if (deg % 450 == 0) // rotated 90deg cw
			this.x += 1;
		else if (deg % 540 == 0) // rotated 180 deg cw
			this.y += 1;
		else // rotated 270deg cw
			this.x -= 1; 
	}
	moveLeft(deg)
	{
		this.deg = deg;
		
		if (deg % 360 == 0) // absolute up right orientation 
			this.x -= 1;
		else if (deg % 450 == 0) // rotated 90deg cw
			this.y -= 1;
		else if (deg % 540 == 0) // rotated 180 deg cw
			this.x += 1;
		else // rotated 270deg cw
			this.y += 1; 
	}
	print()
	{
		return "X: " + this.x + " Y: " + this.y;
	}
}

class Coordinate
{
	constructor(inX, inY)
	{
		this.x = inX;
		this.y = inY;
	}
}

// Effects: creates a map on that is the shape of given coordinates
function createCell(coordinates)
{
	/*
	// remove redundant points
	for (var i = 0; i < coordinates.length - 4; i += 2)
	{
		var x1 = coordinates[i]
		var y1 = coordinates[i+1];
		var x2 = coordinates[i + 2];
		var y2 = coordinates[i + 3];
		var x3 = coordinates[i + 4];
		var y3 = coordinates[i + 5];

		var slope1 = (y2 - y1) / (x2 - x1);
		var slope2 = (y3 - y1) / (x3 - x1);

		if (slope1 == slope2)
			coordinates.splice(i+2, 2);
	}
	*/
	var el = document.createElement("area");
	el.shape = "poly";
	el.coords = "" + coordinates.toString() + "";
	//el.onclick = mapAreaClick();
	el.setAttribute("onclick", "mapAreaClick(" + numCells + ")");
	numCells++;
	//var html = '<area shape="poly" coords="' + coordinates.toString() + '" onclick="mapAreaClick()">';
	document.getElementById('gridMap').appendChild(el);
}

// Requires: coordinates of starting pixel
// Effects: Finds the perimiter of each grid cell and defines the coordinates
// returns a coordinate pair where x = right most value of cell and y = bottom most point in cell
function findAndDefine(x,y, criteria, ctx, imgData)
{
	var startPixel = new Pixel(x, y, imgData); //start pixel is top left of cell, where UpPixelCheck == true
	var pixel = new Pixel(x,y, imgData);
	var cellCoords = [];
	var movedUp = false;
	var curDeg = 360;
	var done = false;
	var i = 0;
	var farRight = 0;
	var farDown = 0;
	
	do
	{
		if (pixel.x == startPixel.x && pixel.y == startPixel.y && i > 0)
			done = true;
		else if (i > 1200)
			done = true;
		i +=1;
		if (pixel.x > farRight)
			farRight = pixel.x;
		if (pixel.y > farDown)
			farDown = pixel.y;
		
		console.log(pixel.print() + " Deg: " + curDeg + " " + i);
		
		var rightPixelCheck = new Pixel(pixel.x, pixel.y, imgData);
		var upPixelCheck = new Pixel(pixel.x, pixel.y, imgData);
		var leftPixelCheck = new Pixel(pixel.x, pixel.y, imgData);
		rightPixelCheck.moveRight(curDeg);
		upPixelCheck.moveUp(curDeg);
		leftPixelCheck.moveLeft(curDeg);
		var color_rightPixelCheck = rightPixelCheck.getHex();
		var color_upPixelCheck = upPixelCheck.getHex();
		var color_leftPixelCheck = leftPixelCheck.getHex();
		
	
		
		// Starting to move off curve, curve changed, rotate
		if (movedUp == true && color_upPixelCheck != criteria && color_leftPixelCheck != criteria)
		{	
			//alert(pixel.print() + " leftPix: " + leftPixelCheck.print() +" upPix: " + upPixelCheck.print() + " rightPix " + rightPixelCheck.print() + " CurDeg: " + curDeg);
			curDeg -= 90; // rotate 90deg ccw
			pixel.moveUp(curDeg);
			cellCoords.push(pixel.x);
			cellCoords.push(pixel.y);
			movedUp == false;
			continue;
		}

		// Move right 1 pixel
		if (color_rightPixelCheck != criteria && color_upPixelCheck == criteria)
		{
			pixel.moveRight(curDeg);
			if (movedUp == true) // store pixel after going up then right
			{
				cellCoords.push(pixel.x);
				cellCoords.push(pixel.y);
				movedUp = false; // reset
			}
			var idx = (pixel.y * imgData.width + pixel.x) * 4;
			imgData.data[idx] = 255;
			imgData.data[idx+1] = 0;
			imgData.data[idx+2] = 0;
			imgData.data[idx+3] = 255;
			continue;
		}

		// Move up 1 pixel
		if (color_upPixelCheck != criteria)
		{
			pixel.moveUp(curDeg);
			movedUp = true;
			var idx = (pixel.y * imgData.width + pixel.x) * 4;
			imgData.data[idx] = 255;
			imgData.data[idx+1] = 0;
			imgData.data[idx+2] = 0;
			imgData.data[idx+3] = 255;
			continue;
		}

		// Hit corner, rotate
		if (color_upPixelCheck == criteria  && color_rightPixelCheck == criteria)
		{	
			curDeg += 90; //rotate 90deg cw
			cellCoords.push(pixel.x);
			cellCoords.push(pixel.y);
			continue;
		}
	
	}
	while (done == false);

	ctx.putImageData(imgData, 0, 0); //show traced cell

	//alert(JSON.stringify(cellCoords));
	createCell(cellCoords);

	// Fill in second canvas with traced area
	var c2 = document.getElementById('results').getContext('2d');
	c2.fillStyle = 'rgba(255, 0, 0, .333)';
	c2.beginPath();
	c2.moveTo(startPixel.x, startPixel.y);
	for (var i = 0; i < cellCoords.length; i += 2)
	{
		c2.lineTo(cellCoords[i], cellCoords[i+1]);
	}
	c2.closePath();
	c2.fill();


	return new Coordinate(farRight + 1, farDown + 1);
}


function mapAreaClick(num)
{
	alert("hey im cell #" + num);
}

function run(numRows, numCols)
{

	//start at top left of photo, find first pixel that doesnt meet criteria and upPixel does

	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	var img = document.getElementById("grid");
	ctx.drawImage(img, 0, 0);
	var imgData = ctx.getImageData(0, 0, c.width, c.height);
	ctx.putImageData(imgData, 0, 0);

	var x; 
	var y;
	var criteria = "#000000";
	var itr = 0;
	var visited = [];

	while (visited.length < numRows * numCols + (numRows - 1)) //go through each cell, one cell is visited twice per row
	{

		for (var i = itr; i < imgData.data.length; i += 4) //find starting point in cell
		{
			var hex = rgbToHex(imgData.data[i], imgData.data[i+1], imgData.data[i+2]);
			if (hex != criteria)
			{
				x = (i / 4) % imgData.width;
				y = (i / 4) / imgData.width;
				x = Math.floor(x);
				y = Math.floor(y);
				i = imgData.data.length; //break loop
			}
		}
		
		//alert(x + " " + y);
		var resultsCoord = findAndDefine(x,y, criteria, ctx, imgData);
		
		//alert("Res: " + resultsCoord.x + " " + resultsCoord.y);
		itr = (y * imgData.width + resultsCoord.x) * 4; // search right
		for (var i = 0; i < visited.length; i++)
		{
			if (visited[i].x == resultsCoord.x && visited[i].y == resultsCoord.y)
			{
				itr = (resultsCoord.y * imgData.width + resultsCoord.x) * 4; // search downwards
				alert("Going down: " + x + " " + y);
				i = visited.length; //break
			}
		}

		visited.push(resultsCoord);
		document.getElementById('asdf').innerHTML = JSON.stringify(visited);
	} // end while
}


// Thanks to TIm Down on stackoverflow
function componentToHex(c) 
{
	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) 
{
	return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

</script>